<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
  <title>Cam√©ra live NB + Overlay (1080√ó1920)</title>
  <style>
    html,body { height:100%; margin:0; background:#000; color:#fff; font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    #container { position:relative; width:100%; height:100vh; overflow:hidden; }

    /* Canvas de preview (plein √©cran). On le laisse pointer-events:none pour que les contr√¥les re√ßoivent les interactions. */
    #canvas {
      position:absolute;
      top:0; left:0;
      width:100%;
      height:100%;
      touch-action:none;
      z-index:1;
      pointer-events: none;
      background:black;
      display:block;
    }

    /* Controls au dessus */
    #controls {
      position:absolute;
      left:50%;
      bottom:12px;
      transform:translateX(-50%);
      z-index:40;
      width:92%;
      max-width:420px;
      padding:10px;
      background:rgba(0,0,0,0.45);
      border-radius:12px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:8px;
      -webkit-tap-highlight-color: transparent;
      pointer-events: auto;
    }
    #threshold { width:100%; }
    #capture {
      width:100%;
      padding:10px;
      font-size:18px;
      border-radius:8px;
      border:0;
      background:#1db954;
      color:white;
      cursor:pointer;
      -webkit-user-select:none;
    }

    /* Aper√ßu r√©sultat (plein √©cran quand affich√©) */
    #result {
      position:fixed;
      inset:0;
      width:100%;
      height:100%;
      object-fit:contain;
      z-index:60;
      background:black;
      display:none;
      touch-action:none;
    }

    /* petite info en haut */
    #topInfo {
      position:absolute;
      top:10px;
      left:50%;
      transform:translateX(-50%);
      z-index:40;
      color:#fff;
      background:rgba(0,0,0,0.25);
      padding:6px 8px;
      border-radius:8px;
      font-size:14px;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div id="container">
    <!-- video cach√©e : source brute -->
    <video id="video" autoplay playsinline muted style="display:none;"></video>

    <!-- canvas visible (preview) -->
    <canvas id="canvas"></canvas>

    <!-- aper√ßu full-screen du r√©sultat -->
    <img id="result" alt="R√©sultat" />

    <div id="topInfo">Seuil : <span id="thresholdValue">128</span></div>

    <div id="controls" aria-hidden="false">
      <input id="threshold" type="range" min="0" max="255" value="128" />
      <button id="capture" type="button">üì∏ Prendre la photo (1080√ó1920)</button>
    </div>
  </div>

  <script>
    (function(){
      const video = document.getElementById('video');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      const threshold = document.getElementById('threshold');
      const thresholdValue = document.getElementById('thresholdValue');
      const captureBtn = document.getElementById('capture');
      const result = document.getElementById('result');

      // overlay (doit √™tre servi depuis le m√™me origin que la page)
      const overlay = new Image();
      overlay.src = "calque.png";
      let overlayReady = false;
      overlay.onload = () => { overlayReady = true; console.log("Overlay charg√©"); };

      // Canvas de capture (hidden) ‚Äî 1080x1920 portrait
      const captureCanvas = document.createElement('canvas');
      const captureCtx = captureCanvas.getContext('2d', { willReadFrequently: true });
      captureCanvas.width = 1080;
      captureCanvas.height = 1920;

      let playing = false;
      let videoWidth = 1280, videoHeight = 720;

      // Start camera (rear by default)
      navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
        .then(stream => {
          video.srcObject = stream;
          return video.play();
        })
        .then(() => {
          // Wait for dimensions
          video.addEventListener('loadedmetadata', () => {
            videoWidth = video.videoWidth || video.clientWidth || 1280;
            videoHeight = video.videoHeight || video.clientHeight || 720;

            // Set internal canvas pixel size to the video size (keeps quality)
            canvas.width = videoWidth;
            canvas.height = videoHeight;

            // Kick off preview loop
            playing = true;
            requestAnimationFrame(drawFrame);
          }, { once: true });
        })
        .catch(err => {
          console.error("Acc√®s cam√©ra impossible :", err);
          alert("Impossible d'acc√©der √† la cam√©ra : " + (err && err.message ? err.message : err));
        });

      // Draw preview each frame. Read slider live.
      function drawFrame() {
        if(!playing) return;
        // draw raw video into canvas (full video resolution)
        try {
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        } catch(e) {
          // video might not be ready yet
        }

        // Apply threshold using current slider value
        const t = parseInt(threshold.value, 10) || 128;
        thresholdValue.textContent = t;

        try {
          const img = ctx.getImageData(0,0,canvas.width,canvas.height);
          const d = img.data;
          for(let i=0;i<d.length;i+=4){
            const r = d[i], g = d[i+1], b = d[i+2];
            const avg = (r+g+b)/3;
            const v = avg > t ? 255 : 0;
            d[i] = d[i+1] = d[i+2] = v;
          }
          ctx.putImageData(img,0,0);
        } catch(e) {
          // getImageData can fail if canvas is tainted by cross-origin images
          // we silently skip threshold in that case
          // console.warn("getImageData failed (canvas may be tainted):", e);
        }

        // Draw overlay if ready (overlay must be same-origin or CORS-enabled)
        if(overlayReady){
          try {
            ctx.drawImage(overlay, 0, 0, canvas.width, canvas.height);
          } catch(e){
            // ignore
          }
        }

        requestAnimationFrame(drawFrame);
      }

      // Ensure controls respond quickly on touch devices:
      function captureImage() {
        // use the current slider value
        const t = parseInt(threshold.value, 10) || 128;

        // compute crop (center-crop) from the video stream to match target ratio 1080/1920
        const videoRatio = videoWidth / videoHeight;
        const targetRatio = 1080 / 1920;
        let sx, sy, sw, sh;

        if(videoRatio > targetRatio){
          // video too wide -> crop horizontally
          sh = videoHeight;
          sw = sh * targetRatio;
          sx = (videoWidth - sw) / 2;
          sy = 0;
        } else {
          // video too tall -> crop vertically
          sw = videoWidth;
          sh = sw / targetRatio;
          sx = 0;
          sy = (videoHeight - sh) / 2;
        }

        // Draw the cropped video into the capture canvas (1080x1920)
        try {
          captureCtx.clearRect(0,0,captureCanvas.width,captureCanvas.height);
          captureCtx.drawImage(video, sx, sy, sw, sh, 0, 0, captureCanvas.width, captureCanvas.height);
        } catch(e){
          console.error("Erreur drawImage pour capture :", e);
        }

        // Apply threshold on capture canvas
        try {
          const img = captureCtx.getImageData(0,0,captureCanvas.width,captureCanvas.height);
          const d = img.data;
          for(let i=0;i<d.length;i+=4){
            const r = d[i], g = d[i+1], b = d[i+2];
            const avg = (r+g+b)/3;
            const v = avg > t ? 255 : 0;
            d[i] = d[i+1] = d[i+2] = v;
          }
          captureCtx.putImageData(img,0,0);
        } catch(e) {
          console.error("getImageData failed on capture (canvas likely tainted):", e);
          alert("Impossible d'appliquer le filtre : v√©rifie que votre overlay (calque.png) est servi depuis le m√™me domaine (m√™me repo).");
        }

        // Draw overlay on capture (if ready)
        if(overlayReady){
          try {
            captureCtx.drawImage(overlay, 0, 0, captureCanvas.width, captureCanvas.height);
          } catch(e){
            console.warn("Impossible de dessiner l'overlay sur la capture :", e);
          }
        }

        // Show preview and trigger download
        captureCanvas.toBlob(blob => {
          if(!blob) {
            alert("Erreur lors de la g√©n√©ration de l'image.");
            return;
          }
          // preview
          const url = URL.createObjectURL(blob);
          result.src = url;
          result.style.display = "block";

          // automatic download
          const a = document.createElement('a');
          const now = new Date();
          const fn = `photo_${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}.png`;
          a.href = url;
          a.download = fn;
          document.body.appendChild(a);
          a.click();
          a.remove();

          // revoke after a bit
          setTimeout(()=> URL.revokeObjectURL(url), 60000);
        }, 'image/png');
      }

      // Hook both click and touchend for fast response on mobile
      captureBtn.addEventListener('click', (e) => { e.preventDefault(); captureImage(); });
      captureBtn.addEventListener('touchend', (e) => { e.preventDefault(); captureImage(); });

      // result click closes preview and revokes URL
      result.addEventListener('click', () => {
        // if src is object URL revoke it
        try { URL.revokeObjectURL(result.src); } catch(e){}
        result.style.display = "none";
        result.src = "";
      });

      // Improve slider UX: update label on input (live)
      threshold.addEventListener('input', () => { thresholdValue.textContent = threshold.value; });

      // Optional: handle resize so displayed canvas still covers screen
      window.addEventListener('resize', () => {
        // Canvas internal pixel size (video dims) remains, CSS handles appearance (100% width/height)
        // Nothing needed here unless you want to re-compute layout.
      });
    })();
  </script>
</body>
</html>
